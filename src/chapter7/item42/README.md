## 7장 - 람다와 스트림

### <아이템42 > 익명 클래스보다는 람다를 사용하라 

> **(요약)** 자바가 8로 판올림되면서 작은 함수 객체를 구현하는 데 적합한 람다가 도입되었다. 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하라.

예전에는 자바에서 함수 타입을 표현할 때 -> 추상 메서드를 하나만 담은 인터페이스를 사용했다.

이런 인터페이스의 인스턴스를 **함수 객체(function object)** 라고 하여, 특정 함수나 동작을 나타내는데 사용했다.

-> JDK 1.1 이 등장하면서 함수 객체를 만드는 주요 수단은 **익명 클래스**가 되었다.

```java
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

But, 익명 클래스 방식은 코드가 너무 길기 때문에.. 자바는 함수형 프로그래밍에 적합하지 않았다.

<span style='color:skyblue'>자바 8에 와서 추상 메서드 하나짜리 인터페이스는 특별한 의미를 인정받아 특별한 대우를 받게 되었다.</span>

- 람다식(lambda expression) 을 사용해 만들 수 있게 되었다.

위 코드는 아래와 같이 간단하게 바꿀 수 있다.
```java
Collections.sort(words2, (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

- 매개변수 (s1, s2)에 대한 타입이 없지만, 이는 컴파일러가 문맥을 보고 타입을 추론해서 문제가 없는 것이다.
- 상황에 따라서 타입 추론이 힘들다 싶으면, 직접 명시해주면 된다.
- 타입을 명시해야 코드가 더 명확할 때만 제외하고는, 가급적 람다의 모든 매개변수 타입은 생략하자.

```java
// 비교 생성자 메서드를 이용해도 된다.
Collections.sort(words3, comparingInt(String::length));

// 자바8 부터는 List 자체에 있는 sort 함수를 이용해도 된다.
words4.sort(comparingInt(String::length));
```

하지만!!

- 람다는 이름이 없고 문서화도 못 한다.
- 따라서, 코드 자체로 동작히 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 쓰지 말아야 한다.
- 한줄이면 좋고, 길어도 3줄안에 끝내는 게 좋다.
- 람다는 함수형 인터페이스에서만 쓰인다.

그러면 무조건 람다가 답일까?

람다로 대체할 수 없는 곳이 있다.

- 추상 클래스의 인스턴스를 만들 때, 람다를 쓸 수 없으므로 익명 클래스를 써야 한다.
- 추상 메서드가 여러개 있는 인터페이스의 인스턴스를 만들 때도 익명 클래스를 쓸 수 있다.
- 람다는 자신을 참조할 수 없다. 람다에서의 this 키워드는 바깥 인스턴스를 가리킨다.
- 따라서, 함수 객체가 자신을 참조해야 한다면 반드시 익명 클래스를 써야 한다.

람다를 직렬화하는 일은 극히 삼가야 한다!!

코드, [Item42.java](https://github.com/ziippy/EffectiveJava/blob/master/src/chapter7/item42/Item42.java)
